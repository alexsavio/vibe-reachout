# Requirements Quality Checklist: Telegram Permission Hook

**Purpose**: Pre-implementation validation of spec completeness, clarity, and consistency across all domains (IPC, Telegram UI, CLI, security, reliability)
**Created**: 2026-02-23
**Feature**: [spec.md](../spec.md) | [plan.md](../plan.md) | [tasks.md](../tasks.md)

**Note**: This checklist is generated by the `/speckit.checklist` command based on feature context and requirements.

## Requirement Completeness

- [x] CHK001 Are all HookInput fields that the hook must forward to IPC explicitly listed? (e.g., `transcript_path` is in HookInput but not in IpcRequest — is this intentional?) [Completeness, Spec §Key Entities] — Intentional: transcript_path is not needed by the bot; IpcRequest only forwards fields relevant to Telegram message formatting
- [x] CHK002 Are requirements defined for what happens when the bot successfully sends to some but not all authorized chat_ids? (e.g., 3 chat IDs configured, 1 fails) [Completeness, Gap, Spec §FR-008] — FIXED: FR-008 now specifies "skip failures, proceed if at least one succeeds"
- [x] CHK003 Are requirements specified for bot startup validation of the Telegram bot token? (e.g., call `getMe` to verify token before binding socket) [Completeness, Gap, Spec §US3] — Covered by edge case: "invalid bot token → bot fails to start with clear error message". teloxide validates token on first API call
- [x] CHK004 Is the `permission_mode` field from HookInput used anywhere in the decision flow, or explicitly documented as pass-through/ignored? [Completeness, Spec §Key Entities] — Not forwarded to IPC, not used in decision logic. It's available in HookInput for future use but currently informational only
- [x] CHK005 Are requirements defined for the hook's behavior when stdin is empty or contains malformed JSON? [Completeness, Gap, Spec §FR-003] — FIXED: Added to edge cases and FR-003
- [x] CHK006 Are requirements specified for what PendingRequest fields are stored per chat_id when messages are sent to ALL authorized chats? (one PendingRequest with multiple message_ids, or one per chat?) [Completeness, Gap, Spec §FR-008] — FIXED: data-model.md updated with SentMessage struct and Vec<SentMessage> in PendingRequest

## Requirement Clarity

- [x] CHK007 Is "within 2 seconds" (FR-001) measured from stdin read to Telegram API send, or from stdin read to Telegram message delivery? [Clarity, Spec §FR-001] — Measured from hook receiving stdin to bot calling Telegram sendMessage API. Delivery latency is Telegram's responsibility
- [x] CHK008 Is the deny message format for Reply ("User replied: {text}") explicitly defined in the spec, not just in contracts? [Clarity, Spec §FR-009] — FIXED in previous session: FR-009 now says 'formatted as "User replied: {text}"'
- [x] CHK009 Is "project name" derivation fully specified? (cwd basename is clear, but "configurable override" is mentioned in FR-008 — where in config? what field name?) [Clarity, Spec §FR-008] — FIXED: Removed "configurable override" from FR-008. Project name is always derived from cwd basename. Config override deferred to future enhancement
- [x] CHK010 Is the socket path fallback chain unambiguous? Spec says platform-dependent default; contract says XDG_RUNTIME_DIR then /tmp. Is the contract authoritative? [Clarity, Spec §Constraints vs contracts/ipc.md] — Yes, contracts/ipc.md is authoritative for protocol details. Spec delegates to contract
- [x] CHK011 Is "at least 10 concurrent permission requests" (FR-002) a hard limit or a minimum target? Are requirements defined for behavior beyond 10? [Clarity, Spec §FR-002] — Minimum target. No hard limit enforced; DashMap + tokio naturally scale. 10 is the design validation threshold
- [x] CHK012 Is the hook timeout (600s in settings.json) vs bot timeout (300s default in config.toml) relationship clarified? Which fires first and what happens? [Clarity, contracts/hook-io.md §Hook Configuration vs Spec §US4] — FIXED: Added edge case clarifying bot timeout fires first (300s), hook timeout (600s) is safety net

## Requirement Consistency

- [x] CHK013 Are the Decision enum values consistent across all artifacts? (data-model.md, contracts/ipc.md, tasks.md all define Allow/Deny/AlwaysAllow/Reply/Timeout) [Consistency] — Verified consistent across all 3 artifacts
- [x] CHK014 Is PendingRequest.chat_id singular in data-model.md but FR-008 requires sending to ALL chat_ids? Does PendingRequest need a Vec of (chat_id, message_id) pairs? [Consistency, Spec §FR-008 vs data-model.md §PendingRequest] — FIXED: data-model.md updated with sent_messages: Vec<SentMessage>
- [x] CHK015 Are exit code semantics consistent? Spec says exit 1 for fallback; contracts/hook-io.md says exit 2 for blocking error. Are both documented in the spec? [Consistency, Spec §FR-003 vs contracts/hook-io.md §Exit Codes] — FIXED: FR-003 now documents exit code 2 as reserved for blocking errors
- [x] CHK016 Is the ReplyState map (chat_id -> request_id) documented in data-model.md? It appears in tasks (T032) and telegram-ui contract but not in the entity model. [Consistency, Gap, data-model.md] — FIXED: Added ReplyState entity to data-model.md
- [x] CHK017 Are inline keyboard button labels consistent between contracts/telegram-ui.md and tasks.md? (e.g., tasks say "Reply" button, contract shows "Reply") [Consistency] — Verified consistent: both use emoji prefixed labels

## Acceptance Criteria Quality

- [x] CHK018 Can US1 AS1 ("Telegram message appears within 2s") be objectively measured in an automated test? [Measurability, Spec §US1] — Measurable via IPC round-trip timing in integration tests. Telegram delivery adds variable latency but sendMessage API call timing is measurable
- [x] CHK019 Is US2 AS2 ("Claude adjusts its approach, no retry of the same command") testable from the hook's perspective, or does it depend on Claude's behavior? [Measurability, Spec §US2] — Depends on Claude's behavior; hook only outputs deny JSON with message. This AS validates Claude Code's contract, not our tool. Acceptable as-is
- [x] CHK020 Are US3 acceptance scenarios sufficient to validate all three startup paths? (normal start, already running, stale socket) [Measurability, Spec §US3] — Yes, 3 acceptance scenarios cover 3 startup paths explicitly
- [x] CHK021 Is US6 AS3 ("reply is rejected, must contain at least 1 character") defined with behavior — does the bot re-prompt, show an error toast, or silently ignore? [Measurability, Spec §US6] — FIXED: Added edge case clarifying "bot re-prompts with ForceReply, ReplyState remains active"

## Scenario Coverage

- [x] CHK022 Are requirements defined for what happens when the bot process crashes WHILE a hook is waiting for a response? (socket connection drops mid-wait) [Coverage, Gap, Exception Flow] — Covered by FR-003: any error → exit code 1. Socket read error (broken pipe/connection reset) → hook exits 1 → terminal fallback
- [x] CHK023 Are requirements defined for the hook receiving a response with an unknown/unexpected `decision` value? [Coverage, Gap, Exception Flow] — Serde deserialization will fail on unknown enum variant → treated as malformed response → exit 1 (fallback). Covered by FR-003
- [x] CHK024 Are requirements defined for Telegram API returning errors on message edit (e.g., message too old to edit)? [Coverage, Gap, Spec §US1 AS2] — Message edits are best-effort. If edit fails, log warning but don't affect the IPC response (decision already sent to hook). Acceptable risk
- [x] CHK025 Are requirements specified for what happens when the user taps Reply but then sends a message in a different chat or to a different bot? [Coverage, Gap, Spec §US6] — ReplyState maps chat_id → request_id. Messages in other chats won't match. ForceReply is chat-specific in Telegram. No issue
- [x] CHK026 Are multi-device scenarios fully covered? (e.g., user taps Reply on phone, then Allow on desktop — which wins?) [Coverage, Spec §US8 AS3] — First response wins via DashMap::remove atomicity. Reply sets ReplyState but doesn't resolve PendingRequest until text arrives. If Allow comes first, it resolves; Reply's ForceReply response will hit "already handled"

## Edge Case Coverage

- [x] CHK027 Is behavior defined when `tool_input` contains very large content? (e.g., Write with 100KB file content — truncation in Telegram message is defined, but what about IPC payload size?) [Edge Case, Gap] — IPC has no size limit (Unix socket streams). Telegram message truncation (4000 chars) handles display. Large tool_input flows through IPC unmodified
- [x] CHK028 Is behavior defined when `cwd` path contains Unicode or special characters? (affects project name derivation and Telegram message formatting) [Edge Case, Gap] — Rust strings are UTF-8 by default. Path::file_name() handles Unicode. Telegram supports Unicode in messages. No special handling needed
- [x] CHK029 Is behavior defined when multiple hooks fire at the exact same instant and race to connect to the socket? [Edge Case, Spec §FR-002] — tokio UnixListener.accept() serializes connections. Each gets its own task. DashMap handles concurrent inserts. No race condition
- [x] CHK030 Is the maximum callback_data size (43 bytes) validated against ALL possible UUID formats? (hyphens, uppercase, etc.) [Edge Case, contracts/ipc.md §Telegram Callback Data] — UUID v4 lowercase with hyphens is always 36 chars. Rust's uuid crate produces lowercase by default. 36 + 1 + 6 = 43 bytes. Safe
- [x] CHK031 Are requirements defined for config file changes while the bot is running? (hot-reload vs restart required) [Edge Case, Gap] — Config is loaded once at startup. Changes require bot restart. This is standard for CLI tools and documented implicitly by startup-only config loading

## Non-Functional Requirements

- [x] CHK032 Is SC-005 (memory <50MB idle, <100MB with 10 requests) testable with defined measurement methodology? [Measurability, Spec §SC-005] — Best-effort target validated manually via system tools (ps, Activity Monitor). Not automated. Acceptable for single-user CLI tool
- [x] CHK033 Are logging requirements specific enough? (what events MUST be logged at each level — info, warn, error) [Completeness, Spec §Constraints] — Sufficient for implementation: tracing crate with RUST_LOG env var. Specific log events emerge during implementation. Level defaults (warn for hook, info for bot) are specified
- [x] CHK034 Are requirements defined for bot process resource cleanup on unclean shutdown (kill -9)? [Gap, Reliability] — Socket file persists after kill -9. Stale socket detection (US3 AS3, T011) handles this on next startup. Acceptable
- [x] CHK035 Is the cross-compilation target list exhaustive? (plan.md lists 3 targets; are there requirements for testing on each?) [Coverage, Spec §Constraints] — 3 targets specified (aarch64-apple-darwin, aarch64-unknown-linux-gnu, x86_64-unknown-linux-gnu). CI testing deferred to polish phase

## Dependencies & Assumptions

- [x] CHK036 Is the assumption that Telegram's callback_data limit remains 64 bytes documented as an external dependency? [Assumption, contracts/ipc.md] — Documented in contracts/ipc.md with size calculation. Stable since Bot API 2.0 (2016). Acceptable assumption
- [x] CHK037 Is the assumption that Claude Code's hook API stdin/stdout contract is stable documented? (API could change between Claude Code versions) [Assumption, contracts/hook-io.md] — Documented in contracts/hook-io.md with source link. Hook API is public and versioned. Acceptable assumption
- [x] CHK038 Are Telegram Bot API version requirements documented? (teloxide 0.13 targets a specific Bot API version) [Dependency, Gap] — teloxide 0.13 targets Bot API 7.x. Documented in research.md dependency matrix. Acceptable
- [x] CHK039 Is the assumption that `dirs` crate correctly resolves XDG paths on all target platforms validated? [Assumption, contracts/ipc.md] — dirs crate is well-maintained and tested. Fallback to /tmp is documented. Acceptable assumption

## Notes

- Check items off as completed: `[x]`
- All 39 items reviewed and resolved
- 7 items required spec/data-model fixes (CHK002, CHK005, CHK006, CHK009, CHK012, CHK014-CHK016, CHK021)
- 32 items resolved by analysis (requirements adequate as-is or covered by existing mechanisms)
